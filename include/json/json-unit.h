/*
 * Copyright (C) 2014-2015 Vy Nguyen
 * Github https://github.com/vy-nguyen/c-libraries
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#ifndef _JSON_JSON_UNIT_H_
#define _JSON_JSON_UNIT_H_

#include <stdlib.h>
#include <boost/thread/barrier.hpp>
#include <json/json-obj.h>
#include <di/request.h>

class SyncLock;
namespace jsunit {

class JsRequest : public Request
{
  public:
    OBJECT_COMMON_DEFS(JsRequest);

    void req_exec_task() override;
    JsBase::ptr js_get_run() { return js_run; }

  protected:
    int                    js_inst_no;
    int                    js_inst_count;
    char                  *js_verb;
    JsBase::ptr            js_run;

    ~JsRequest()
    {
        js_run = NULL;
        if (js_verb != NULL) {
            std::free(js_verb);
        }
    }
    JsRequest(JsBase::ptr obj, const char *verb, int no, int cnt) :
        js_inst_no(no), js_inst_count(cnt),
        js_verb(verb != NULL ? strdup(verb) : NULL), js_run(obj) {}
};

class CpuInOut : public JsOutput
{
  public:
    OBJECT_COMMON_DEFS(CpuInOut);

    inline bool is_barrier() {
        return out_barrier;
    }

  protected:
    bool   out_barrier;

    CpuInOut(bool barrier, JsBase::ptr obj) : JsOutput()
    {
        out_jobj = obj;
        out_barrier = barrier; 
    }
};

class RunSpec;
class TestVerb;
class TestCase;
class TestDriver;

/**
 * ------------------------------------------------------------------------------------
 * Common TestElm object.  Contains instances for each test case, driven by TestDriver.
 * It's auto generated by ObjSpec/ObjData
 * ------------------------------------------------------------------------------------
 */
class TestElm : public JsBase
{
  public:
    OSlink             te_slink;
    ODlink             te_dlink1;
    ODlink             te_dlink2;

    OBJECT_COMMON_DEFS(TestElm);

    /**
     * Provide implementation for these methods.
     */
    virtual void js_exec(const char *verb, JsOutput::ptr out) override;

    virtual JsBase::ptr
    js_clone(JsBase::ptr p, json_t *js, const char *id) const override
    {
        JsBase::ptr obj = TestElm::alloc(p, true, id, -1, js);
        obj->js_init();
        return obj;
    }

    boost::intrusive_ptr<TestCase> js_get_test_case();
    inline void js_set_test_driver(boost::intrusive_ptr<TestDriver> driver) {
        te_driver = driver;
    }

    template <typename T>
    inline boost::intrusive_ptr<T> js_get_test_case() {
        return reinterpret_cast<T *>(js_get_test_case().get());
    }

    uint64_t obj_key64() const override;
    uint64_t obj_key_dlink(const ODlink *p) const override;
    int      obj_hash_dlink(int size, const ODlink *p) const override;
    int      obj_compare_dlink(const ODlink *p) const override;

    uint64_t obj_key_slink(const OSlink *p) const override;
    int      obj_hash_slink(int size, const OSlink *p) const override;
    int      obj_compare_slink(const OSlink *p) const override;

  protected:
    TestElm(JsBase::ptr parent, bool has_id, const char *id, int idx, json_t *json) :
        JsBase(parent, has_id, id, idx, json), te_slink(NULL) {}

    boost::intrusive_ptr<TestDriver> te_driver;
};

class TestElmDecode : public JsDecode
{
  public:
    TestElmDecode(const char *const key, const JsDecode *const *curr,
            const JsDecode *up) : JsDecode(key, typeid(TestElm).name(), curr, up) {}

    virtual JsBase::ptr
    js_alloc(JsBase::ptr pa, bool has_id,
             const char *id, int idx, json_t *js) const override {
        return TestElm::alloc(pa, has_id, id, idx, js);
    }
};

extern const TestElmDecode g_test_elm_decode;

/**
 * ------------------------------------------------------------------------------------
 * TestDriver acts as barrier to be called at the begin and end of test objects.
 *
 * TestDriver is conduit to link with TestCase.  It allows us to call user-defined
 * TestCase from static, uniform format shared by all JSON tests.  TestCase registers
 * to bind with TestDriver at initialization time.
 * ------------------------------------------------------------------------------------
 */
class TestDriver : public JsBase
{
  public:
    OBJECT_COMMON_DEFS(TestDriver);

    void js_init() override;
    void js_exec(const char *verb, JsOutput::ptr out) override;

    const TestVerb *const js_get_verb(const char *verb);
    void js_add_test_case(const TestVerb *const v[], boost::intrusive_ptr<TestCase>);

    void js_barrier() override {
        test_sync.wait();
    }

    inline boost::intrusive_ptr<TestCase> js_get_test_case() {
        return test_inst;
    }

    /**
     * Go through each TestElm, invoke TestCase::apply_each_test_elm.
     * In the 1st api, callback argument other is null.
     * In the 2nd api, callback argument other is TestElm bound to test_driver name.
     */
    void js_iter_foreach_test_elm();
    void js_iter_foreach_test_elm(const char *test_driver);

    TestDriver::ptr js_get_peer(const char *test_driver);

    /**
     * Plugin to provide content and size generation from json file.
     */
    uint64_t gen_range_num(int order, const char *name);
    size_t   gen_content_str(int order, const char *name, char *out, size_t len);

  protected:
    friend class TestElm;
    friend class RunSpec;
    friend class AsyncTestCase;
    static boost::intrusive_ptr<TestCase> test_cases[];

    boost::barrier                  test_sync;
    StringKvMap                     verb_map;
    boost::intrusive_ptr<TestCase>  test_inst;

    int                             test_elm_beg;    /* all test elements created.    */
    int                             test_elm_end;
    int                             test_elm_exec;
    const char                     *test_elm_name;
    JsManager::ptr                  test_mgr;

    ~TestDriver();
    TestDriver(JsBase::ptr pa, bool has_id, const char *id, int idx, json_t *json) :
        JsBase(pa, has_id, id, idx, json), test_sync(2), verb_map(16),
        test_inst(NULL), test_elm_name(NULL), test_mgr(NULL)  {}

    void js_cleanup() override;
    void js_install_test(const TestVerb *const verbs[]);
    void js_set_test_info(JsManager::ptr mgr, const char *name, int beg, int end);
    bool js_foreach_call(const char *mine, const char *other, int order);
};

class TestDriverDecode : public JsDecode
{
  public:
    TestDriverDecode(const char *const key, const JsDecode *const *curr,
            const JsDecode *up) : JsDecode(key, typeid(TestDriver).name(), curr, up) {}

    virtual JsBase::ptr
    js_alloc(JsBase::ptr pa, bool has_id,
             const char *id, int idx, json_t *js) const override {
        return TestDriver::alloc(pa, has_id, id, idx, js);
    }
};

extern const TestDriverDecode g_test_driver_decode;

/**
 * ------------------------------------------------------------------------------------
 * Plugin for dynamic/user defined test cases.
 * ------------------------------------------------------------------------------------
 */
class TestCase
{
  public:
    OBJECT_COMMON_DEFS(TestCase);
    const char *const test_case;

    virtual void setup_test_case(TestDriver::ptr anchor) {}
    virtual void cleanup_test_case(TestDriver::ptr anchor) {}

    virtual bool
    apply_each_test_elm(TestDriver::ptr, TestElm::ptr mine, TestElm::ptr other) {
        return false;
    }

    virtual void begin_test_case(const char *, TestDriver::ptr, JsOutput::ptr) {
        printf("Base class instance: %s, you shouldn't get here!\n", test_case);
    }
    virtual void end_test_case(const char *, TestDriver::ptr, JsOutput::ptr) {
        printf("End base class instance: %s, you shouldn't get here!\n", test_case);
    }

    virtual void
    run_def_verb(const char *, TestElm::ptr elm, JsOutput::ptr out) {}

    /**
     * Plugin to provide content and size generation from json file.
     */
    virtual uint64_t
    gen_range_num(int order, const char *name) { return 0; }

    virtual size_t
    gen_content_str(int order, const char *name, char *out, size_t len) { return 0; }

    /**
     * Plugin to provide customized hash functions for TestElm through embedded links.
     * TestElm, common to all JSON tests, is static.  It is wired to this user-defined
     * TestCase object to provide custominzed hash functions to chain TestElm through
     * its built-in embeded links.  These hooks make it possible to chain TestElm to
     * different list to avoid copy its data to different object.
     */
    virtual uint64_t obj_key64(const TestElm::ptr o) const {
        return reinterpret_cast<uint64_t>(o.get());
    }

    virtual uint64_t obj_key_dlink(TestElm::ptr o, const ODlink *p) const {
        return reinterpret_cast<uint64_t>(o.get());
    }
    virtual int obj_hash_dlink(TestElm::ptr o, int size, const ODlink *p) const {
        return obj_key_dlink(o, p) % size;
    }
    virtual int obj_compare_dlink(TestElm::ptr o, const ODlink *p) const {
        return o->obj_compare64(p->obj_cptr()->obj_key64());
    }

    virtual uint64_t obj_key_slink(TestElm::ptr o, const OSlink *p) const {
        return reinterpret_cast<uint64_t>(o.get());
    }
    virtual int obj_hash_slink(TestElm::ptr o, int size, const OSlink *p) const {
        return obj_key_slink(o, p) % size;
    }
    virtual int obj_compare_slink(TestElm::ptr o, const OSlink *p) const {
        return o->obj_compare64(p->obj_cptr()->obj_key64());
    }

  protected:
    INTRUSIVE_PTR_DECL(TestCase, m_refcnt);

    virtual ~TestCase() {}
    explicit TestCase(const char *const id) : test_case(id), m_refcnt(0) {}
};

class TestVerb
{
  public:
    TestVerb(const char *const verb) : test_verb(verb) {}

    const char *const test_verb;
    virtual void run_verb(TestElm::ptr, TestCase::ptr tc, JsOutput::ptr out) const {}
};

/**
 * Plugin to provide content and size generation from json file.
 */
inline uint64_t
TestDriver::gen_range_num(int order, const char *name)
{
    return test_inst->gen_range_num(order, name);
}

inline size_t
TestDriver::gen_content_str(int order, const char *name, char *out, size_t len)
{
    return test_inst->gen_content_str(order, name, out, len);
}

/**
 * ------------------------------------------------------------------------------------
 * Common Async Test Case.
 * ------------------------------------------------------------------------------------
 */
class AsyncTestCase : public TestCase
{
  public:
    OBJECT_COMMON_DEFS(AsyncTestCase);

    void begin_test_case(const char *, TestDriver::ptr, JsOutput::ptr) override;
    void end_test_case(const char *, TestDriver::ptr, JsOutput::ptr) override;

    void notify_test_done(int console_count = 1000);

  protected:
    bo::atomic_int           cnt_done;
    SyncLock                *test_sync;

    virtual ~AsyncTestCase();
    AsyncTestCase(const char *const id) :
        TestCase(id), cnt_done(0), test_sync(nullptr) {}
};

/**
 * Common json decoders used by unit test lib.
 */
#define COMMON_UNIT_TEST_DECODE                    \
    &g_exec_run_decode,                            \
    &g_content_spec_decode,                        \
    &g_test_resource_decode,                       \
    &g_cpu_decode,                                 \
    &g_root_decode,                                \
    &g_compare_decode,                             \
    &g_obj_data_decode,                            \
    &g_source_json_decode,                         \
    &g_range_spec_decode,                          \
    &g_network_decode,                             \
    &g_obj_spec_decode,                            \
    &g_import_decode,                              \
    &g_memory_decode,                              \
    &g_run_spec_decode,                            \
    &g_test_elm_decode,                            \
    &g_test_driver_decode

} // namespace jsunit

extern void verify_data_gen(JsManager::ptr mgr);

/**
 * Macro for user-defined TestCase.
 */
#define USER_TEST_CASE_OVERRIDE_METHODS                                            \
    void begin_test_case(const char *, TestDriver::ptr, JsOutput::ptr) override;   \
    void end_test_case(const char *, TestDriver::ptr, JsOutput::ptr) override

#define USER_TEST_CASE_BODY(TestName)                                              \
  public:                                                                          \
    OBJECT_COMMON_DEFS(TestName);                                                  \
    void run_def_verb(const char *, TestElm::ptr elm, JsOutput::ptr out) override

/**
 * Normal test case with begin/end, run_def
 */
#define USER_TEST_CASE_NORMAL(TestName, Parent, PublicDecl, ProtectedDecl)         \
class TestName : public Parent                                                     \
{                                                                                  \
    USER_TEST_CASE_BODY(TestName);                                                 \
    USER_TEST_CASE_OVERRIDE_METHODS;                                               \
    PublicDecl                                                                     \
  protected:                                                                       \
    TestName(const char *const id) : Parent(id) {}                                 \
    ProtectedDecl                                                                  \
}

/**
 * Test case with only run_def.
 */
#define USER_TEST_CASE_RUNONLY(TestName, Parent, PublicDecl, ProtectedDecl)        \
class TestName : public Parent                                                     \
{                                                                                  \
    USER_TEST_CASE_BODY(TestName);                                                 \
    PublicDecl                                                                     \
  protected:                                                                       \
    TestName(const char *const id) : Parent(id) {}                                 \
    ProtectedDecl                                                                  \
}

#define USER_TEST_VERB_DECL(VerbName)                                              \
class VerbName : public TestVerb                                                   \
{                                                                                  \
  public:                                                                          \
    VerbName(const char *v) : TestVerb(v) {}                                       \
    void run_verb(TestElm::ptr elm, TestCase::ptr tc, JsOutput::ptr out) const;    \
}

#endif /* _JSON_JSON_UNIT_H_ */
